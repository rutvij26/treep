<?xml version="1.0" encoding="UTF-8"?>
<testsuites name="jest tests" tests="431" failures="0" errors="0" time="4.353">
  <testsuite name="tests\algorithms\lazy.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.122" tests="24">
    <testcase classname="Lazy Evaluation › lazyBFS" name="should yield leaves in BFS order" time="0.012">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyBFS" name="should handle single leaf" time="0">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyDFS" name="should yield leaves in DFS order" time="0.002">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyDFS" name="should skip already visited nodes" time="0.002">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyDFS" name="should handle nodes pushed multiple times to stack" time="0.001">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyDFS" name="should skip node if already visited when popped from stack" time="0.001">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyAllPaths" name="should yield all paths between two leaves" time="0.001">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyAllPaths" name="should yield single path for direct connection" time="0.001">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyAllPaths" name="should yield empty for no path" time="0.001">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyAllPaths" name="should yield single node path when start equals end" time="0">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyAllPaths" name="should skip cycles in paths" time="0.001">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyAllPaths" name="should skip nodes already in current path (cycle detection)" time="0">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindPaths" name="should yield paths with constraints" time="0.001">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindPaths" name="should respect maxPaths constraint" time="0">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindPaths" name="should respect maxLength constraint" time="0">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindPaths" name="should respect maxWeight constraint" time="0">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindPaths" name="should stop when current weight exceeds maxWeight" time="0.001">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindPaths" name="should return early when currentWeight already exceeds maxWeight" time="0.001">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindPaths" name="should respect leafFilter constraint" time="0">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindPaths" name="should respect branchFilter constraint" time="0.001">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindPaths" name="should filter out branches that do not match branchFilter" time="0">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindPaths" name="should handle maxWeight constraint with weighted branches" time="0">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindLeaves" name="should yield leaves matching predicate" time="0.001">
    </testcase>
    <testcase classname="Lazy Evaluation › lazyFindLeaves" name="should respect limit" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\streaming.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.154" tests="20">
    <testcase classname="Streaming › fromJSONStream" name="should parse JSON array and build graph" time="0.013">
    </testcase>
    <testcase classname="Streaming › fromJSONStream" name="should call onLeaf callback" time="0.001">
    </testcase>
    <testcase classname="Streaming › fromJSONStream" name="should handle custom field names" time="0.001">
    </testcase>
    <testcase classname="Streaming › toJSONStream" name="should stream graph to JSON chunks" time="0.002">
    </testcase>
    <testcase classname="Streaming › toJSONStream" name="should handle empty graph" time="0.002">
    </testcase>
    <testcase classname="Streaming › toJSONStream" name="should respect includeWeights option" time="0.001">
    </testcase>
    <testcase classname="Streaming › toJSONStream" name="should handle includeIds false" time="0.001">
    </testcase>
    <testcase classname="Streaming › toJSONStream" name="should handle multiple branches with comma separator" time="0.001">
    </testcase>
    <testcase classname="Streaming › fromJSONStream edge cases" name="should throw error for invalid JSON type" time="0.028">
    </testcase>
    <testcase classname="Streaming › fromJSONStream edge cases" name="should skip non-object items" time="0.001">
    </testcase>
    <testcase classname="Streaming › fromJSONStream edge cases" name="should skip when fromLeaf is not found in second pass (line 118)" time="0.002">
    </testcase>
    <testcase classname="Streaming › fromJSONStream edge cases" name="should skip items without id field" time="0.001">
    </testcase>
    <testcase classname="Streaming › fromJSONStream edge cases" name="should skip items that are not objects in second pass" time="0.001">
    </testcase>
    <testcase classname="Streaming › fromJSONStream edge cases" name="should skip when fromId is undefined" time="0.001">
    </testcase>
    <testcase classname="Streaming › fromJSONStream edge cases" name="should skip when fromLeaf is not found (line 118)" time="0.001">
    </testcase>
    <testcase classname="Streaming › fromJSONStream edge cases" name="should call onBranch callback" time="0.001">
    </testcase>
    <testcase classname="Streaming › fromJSONStream edge cases" name="should call onBranch callback for simple ID references" time="0">
    </testcase>
    <testcase classname="Streaming › fromJSONStream edge cases" name="should handle simple ID references in branches" time="0.001">
    </testcase>
    <testcase classname="Streaming › fromJSONStream edge cases" name="should call onBranch callback for simple ID reference branches" time="0.001">
    </testcase>
    <testcase classname="Streaming › toAsyncStream" name="should convert generator to async stream" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\transformations.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.118" tests="14">
    <testcase classname="Transformations › reverseGraph" name="should reverse all branches" time="0.013">
    </testcase>
    <testcase classname="Transformations › reverseGraph" name="should preserve leaf values" time="0.001">
    </testcase>
    <testcase classname="Transformations › reverseGraph" name="should preserve branch weights" time="0.001">
    </testcase>
    <testcase classname="Transformations › reverseGraph" name="should handle empty graph" time="0">
    </testcase>
    <testcase classname="Transformations › toUndirected" name="should create bidirectional branches" time="0.001">
    </testcase>
    <testcase classname="Transformations › toUndirected" name="should preserve weights" time="0.001">
    </testcase>
    <testcase classname="Transformations › toUndirected" name="should handle multiple branches" time="0.001">
    </testcase>
    <testcase classname="Transformations › toUndirected" name="should handle empty graph" time="0">
    </testcase>
    <testcase classname="Transformations › transpose" name="should transpose graph (same as reverse)" time="0.001">
    </testcase>
    <testcase classname="Transformations › filterBranches" name="should filter branches by predicate" time="0.001">
    </testcase>
    <testcase classname="Transformations › filterBranches" name="should only include leaves connected by filtered branches" time="0.001">
    </testcase>
    <testcase classname="Transformations › filterLeaves" name="should filter leaves by predicate" time="0.001">
    </testcase>
    <testcase classname="Transformations › filterLeaves" name="should include branches between filtered leaves" time="0.001">
    </testcase>
    <testcase classname="Transformations › filterLeaves" name="should exclude branches to filtered-out leaves" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\subgraph.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.153" tests="13">
    <testcase classname="Subgraph › extractSubgraph" name="should extract subgraph with specified leaves" time="0.018">
    </testcase>
    <testcase classname="Subgraph › extractSubgraph" name="should include branches between selected leaves" time="0.001">
    </testcase>
    <testcase classname="Subgraph › extractSubgraph" name="should exclude branches to external leaves by default" time="0.001">
    </testcase>
    <testcase classname="Subgraph › extractSubgraph" name="should include external branches when option is set" time="0.001">
    </testcase>
    <testcase classname="Subgraph › extractSubgraph" name="should exclude branches when includeBranches is false" time="0.001">
    </testcase>
    <testcase classname="Subgraph › extractSubgraph" name="should handle non-existent leaf IDs" time="0">
    </testcase>
    <testcase classname="Subgraph › extractSubgraph" name="should preserve leaf values" time="0.002">
    </testcase>
    <testcase classname="Subgraph › extractReachableSubgraph" name="should extract all reachable leaves from start" time="0.001">
    </testcase>
    <testcase classname="Subgraph › extractReachableSubgraph" name="should respect maxDepth" time="0.001">
    </testcase>
    <testcase classname="Subgraph › extractReachableSubgraph" name="should return empty graph for non-existent start leaf" time="0.001">
    </testcase>
    <testcase classname="Subgraph › extractReachableSubgraph" name="should handle single leaf" time="0.002">
    </testcase>
    <testcase classname="Subgraph › extractReachableSubgraph" name="should not traverse backwards" time="0.001">
    </testcase>
    <testcase classname="Subgraph › extractReachableSubgraph" name="should include branches in reachable subgraph" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\algorithms\topologicalSort.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.157" tests="12">
    <testcase classname="Topological Sort › topologicalSort" name="should sort simple DAG" time="0.012">
    </testcase>
    <testcase classname="Topological Sort › topologicalSort" name="should handle single leaf" time="0.002">
    </testcase>
    <testcase classname="Topological Sort › topologicalSort" name="should handle empty graph" time="0.001">
    </testcase>
    <testcase classname="Topological Sort › topologicalSort" name="should handle multiple roots" time="0.001">
    </testcase>
    <testcase classname="Topological Sort › topologicalSort" name="should throw error for graph with cycle" time="0.025">
    </testcase>
    <testcase classname="Topological Sort › topologicalSort" name="should handle complex DAG" time="0.002">
    </testcase>
    <testcase classname="Topological Sort › isDAG" name="should return true for acyclic graph" time="0">
    </testcase>
    <testcase classname="Topological Sort › isDAG" name="should return false for graph with cycle" time="0.001">
    </testcase>
    <testcase classname="Topological Sort › isDAG" name="should rethrow non-cycle errors in isDAG" time="0.001">
    </testcase>
    <testcase classname="Topological Sort › isDAG" name="should throw error when isDAG encounters non-cycle error" time="0.001">
    </testcase>
    <testcase classname="Topological Sort › isDAG" name="should return true for empty graph" time="0.001">
    </testcase>
    <testcase classname="Topological Sort › isDAG" name="should return true for single leaf" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\validate.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.137" tests="4">
    <testcase classname="validate" name="should validate simple object" time="0.013">
    </testcase>
    <testcase classname="validate" name="should detect missing required fields" time="0.001">
    </testcase>
    <testcase classname="validate" name="should validate nested objects" time="0.001">
    </testcase>
    <testcase classname="validate" name="should validate leaf" time="0">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\export.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.169" tests="19">
    <testcase classname="Export › toDOT" name="should export empty graph to DOT" time="0.01">
    </testcase>
    <testcase classname="Export › toDOT" name="should export graph with leaves to DOT" time="0.001">
    </testcase>
    <testcase classname="Export › toDOT" name="should export branches to DOT" time="0">
    </testcase>
    <testcase classname="Export › toDOT" name="should include weights when specified" time="0">
    </testcase>
    <testcase classname="Export › toDOT" name="should exclude weights when specified" time="0.001">
    </testcase>
    <testcase classname="Export › toDOT" name="should export as undirected graph" time="0">
    </testcase>
    <testcase classname="Export › toDOT" name="should escape quotes in labels" time="0">
    </testcase>
    <testcase classname="Export › toAdjacencyList" name="should export to adjacency list" time="0.001">
    </testcase>
    <testcase classname="Export › toAdjacencyList" name="should include weights when specified" time="0.001">
    </testcase>
    <testcase classname="Export › toAdjacencyList" name="should handle multiple neighbors" time="0.001">
    </testcase>
    <testcase classname="Export › toEdgeList" name="should export to edge list" time="0.001">
    </testcase>
    <testcase classname="Export › toEdgeList" name="should include weights by default" time="0">
    </testcase>
    <testcase classname="Export › toEdgeList" name="should exclude weights when specified" time="0">
    </testcase>
    <testcase classname="Export › toEdgeList" name="should handle multiple edges" time="0.003">
    </testcase>
    <testcase classname="Export › toAdjacencyMatrix" name="should export to adjacency matrix" time="0.006">
    </testcase>
    <testcase classname="Export › toAdjacencyMatrix" name="should include weights when specified" time="0.001">
    </testcase>
    <testcase classname="Export › toAdjacencyMatrix" name="should use 1 for unweighted edges when includeWeights is false" time="0.001">
    </testcase>
    <testcase classname="Export › toAdjacencyMatrix" name="should handle empty graph" time="0.001">
    </testcase>
    <testcase classname="Export › toAdjacencyMatrix" name="should handle graph with multiple leaves" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\algorithms\dfs.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.157" tests="11">
    <testcase classname="DFS" name="should traverse graph in depth-first order" time="0.015">
    </testcase>
    <testcase classname="DFS" name="should call visit callback for each leaf" time="0.001">
    </testcase>
    <testcase classname="DFS" name="should handle single leaf" time="0.001">
    </testcase>
    <testcase classname="DFS" name="should skip already visited nodes when popped from stack" time="0.001">
    </testcase>
    <testcase classname="DFS" name="should find leaf matching predicate with early termination" time="0.001">
    </testcase>
    <testcase classname="DFS" name="should return undefined if no match found with predicate" time="0.001">
    </testcase>
    <testcase classname="DFS" name="should stop searching once match is found (early termination)" time="0.006">
    </testcase>
    <testcase classname="DFS" name="should find leaf by value property with predicate" time="0">
    </testcase>
    <testcase classname="DFS" name="should handle complex predicate conditions" time="0.002">
    </testcase>
    <testcase classname="DFS" name="should return start leaf if it matches predicate" time="0.002">
    </testcase>
    <testcase classname="DFS" name="should find first match in DFS order (depth-first)" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\serialization.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.156" tests="11">
    <testcase classname="Serialization › toJSON" name="should serialize empty graph" time="0.017">
    </testcase>
    <testcase classname="Serialization › toJSON" name="should serialize graph with leaves only" time="0.003">
    </testcase>
    <testcase classname="Serialization › toJSON" name="should serialize graph with branches" time="0.001">
    </testcase>
    <testcase classname="Serialization › toJSON" name="should exclude weights when includeWeights is false" time="0.002">
    </testcase>
    <testcase classname="Serialization › toJSON" name="should exclude IDs when includeIds is false" time="0.001">
    </testcase>
    <testcase classname="Serialization › toJSON" name="should use custom field names" time="0.003">
    </testcase>
    <testcase classname="Serialization › toJSON" name="should serialize complex value types" time="0.001">
    </testcase>
    <testcase classname="Serialization › toJSON" name="should handle unweighted branches" time="0.001">
    </testcase>
    <testcase classname="Serialization › toJSONString" name="should serialize to JSON string" time="0.002">
    </testcase>
    <testcase classname="Serialization › toJSONString" name="should use custom indentation" time="0.001">
    </testcase>
    <testcase classname="Serialization › toJSONString" name="should produce compact JSON with 0 indent" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\fromJSON.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.176" tests="7">
    <testcase classname="fromJSON" name="should build graph from array of items" time="0.016">
    </testcase>
    <testcase classname="fromJSON" name="should throw error if idField is missing" time="0.021">
    </testcase>
    <testcase classname="fromJSON" name="should handle nested object structure" time="0.002">
    </testcase>
    <testcase classname="fromJSON" name="should throw error for invalid data type" time="0.002">
    </testcase>
    <testcase classname="fromJSON" name="should skip non-object items in array (line 33)" time="0.001">
    </testcase>
    <testcase classname="fromJSON" name="should skip non-object items in second pass (line 50)" time="0.003">
    </testcase>
    <testcase classname="fromJSON" name="should skip when fromLeaf is not found (line 57)" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\errors\ValidationError.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.13" tests="5">
    <testcase classname="ValidationError" name="should create validation error with details" time="0.018">
    </testcase>
    <testcase classname="ValidationError" name="should get all error paths" time="0.001">
    </testcase>
    <testcase classname="ValidationError" name="should get errors for specific path" time="0.001">
    </testcase>
    <testcase classname="ValidationError" name="should create validation error with empty errors array" time="0.001">
    </testcase>
    <testcase classname="ValidationError" name="should create validation error without errors parameter" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\validate-comprehensive.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.218" tests="25">
    <testcase classname="validate - Comprehensive › Type validation" name="should validate string type" time="0.024">
    </testcase>
    <testcase classname="validate - Comprehensive › Type validation" name="should validate number type" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › Type validation" name="should validate boolean type" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › Type validation" name="should validate date type" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › Type validation" name="should validate array type" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › Type validation" name="should validate object type" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › String constraints" name="should validate minLength" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › String constraints" name="should fail minLength validation" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › String constraints" name="should validate maxLength" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › String constraints" name="should validate pattern" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › String constraints" name="should fail pattern validation" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › String constraints" name="should validate enum" time="0">
    </testcase>
    <testcase classname="validate - Comprehensive › Number constraints" name="should validate min" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › Number constraints" name="should validate max" time="0.002">
    </testcase>
    <testcase classname="validate - Comprehensive › Array validation" name="should validate array with item schema" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › Nested object validation" name="should validate deeply nested objects" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › Default values" name="should use default value when field is missing" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › Custom validators" name="should use custom validator" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › Custom validators" name="should fail custom validator" time="0">
    </testcase>
    <testcase classname="validate - Comprehensive › validateBranch" name="should validate branch data" time="0.003">
    </testcase>
    <testcase classname="validate - Comprehensive › validateGraph" name="should validate all leaves in graph" time="0.002">
    </testcase>
    <testcase classname="validate - Comprehensive › validateTree" name="should validate tree structure" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › Edge cases" name="should handle non-object data" time="0">
    </testcase>
    <testcase classname="validate - Comprehensive › Edge cases" name="should handle null data" time="0.001">
    </testcase>
    <testcase classname="validate - Comprehensive › Edge cases" name="should handle array data" time="0">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\normalize-comprehensive.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.17" tests="5">
    <testcase classname="normalize - Comprehensive" name="should throw error for null/undefined required field" time="0.034">
    </testcase>
    <testcase classname="normalize - Comprehensive" name="should convert date strings" time="0.001">
    </testcase>
    <testcase classname="normalize - Comprehensive" name="should not convert types when typeConversions is false" time="0.001">
    </testcase>
    <testcase classname="normalize - Comprehensive" name="should normalize nested arrays" time="0.002">
    </testcase>
    <testcase classname="normalize - Comprehensive" name="should handle deeply nested structures" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="tests\core\Branch.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.145" tests="6">
    <testcase classname="Branch › constructor" name="should create a branch between two nodes" time="0.018">
    </testcase>
    <testcase classname="Branch › constructor" name="should throw error if connecting node to itself" time="0.015">
    </testcase>
    <testcase classname="Branch › isWeighted" name="should return true for weighted branch" time="0">
    </testcase>
    <testcase classname="Branch › isWeighted" name="should return false for unweighted branch" time="0.001">
    </testcase>
    <testcase classname="Branch › getOtherLeaf" name="should return the other leaf" time="0.001">
    </testcase>
    <testcase classname="Branch › getOtherLeaf" name="should throw error if leaf is not part of branch" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="tests\algorithms\treeTraversal.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.211" tests="18">
    <testcase classname="Tree Traversal › preOrder" name="should traverse in pre-order (root, left, right)" time="0.02">
    </testcase>
    <testcase classname="Tree Traversal › preOrder" name="should return all visited nodes" time="0.003">
    </testcase>
    <testcase classname="Tree Traversal › preOrder" name="should handle single node" time="0.001">
    </testcase>
    <testcase classname="Tree Traversal › inOrder" name="should traverse in in-order (left, root, right)" time="0.002">
    </testcase>
    <testcase classname="Tree Traversal › inOrder" name="should return all visited nodes" time="0.002">
    </testcase>
    <testcase classname="Tree Traversal › inOrder" name="should handle single node" time="0.001">
    </testcase>
    <testcase classname="Tree Traversal › postOrder" name="should traverse in post-order (left, right, root)" time="0.002">
    </testcase>
    <testcase classname="Tree Traversal › postOrder" name="should return all visited nodes" time="0.001">
    </testcase>
    <testcase classname="Tree Traversal › postOrder" name="should handle single node" time="0.002">
    </testcase>
    <testcase classname="Tree Traversal › levelOrder" name="should traverse level by level" time="0.002">
    </testcase>
    <testcase classname="Tree Traversal › levelOrder" name="should return all visited nodes" time="0.001">
    </testcase>
    <testcase classname="Tree Traversal › levelOrder" name="should handle single node" time="0">
    </testcase>
    <testcase classname="Tree Traversal › treeTraversal" name="should support pre-order traversal" time="0">
    </testcase>
    <testcase classname="Tree Traversal › treeTraversal" name="should support in-order traversal" time="0">
    </testcase>
    <testcase classname="Tree Traversal › treeTraversal" name="should support post-order traversal" time="0.001">
    </testcase>
    <testcase classname="Tree Traversal › treeTraversal" name="should support level-order traversal" time="0.002">
    </testcase>
    <testcase classname="Tree Traversal › treeTraversal" name="should default to pre-order" time="0.004">
    </testcase>
    <testcase classname="Tree Traversal › treeTraversal" name="should throw error for invalid order" time="0.02">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\binarySearchTree.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.211" tests="19">
    <testcase classname="Binary Search Tree Operations › bstInsert" name="should insert value less than root to left" time="0.023">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstInsert" name="should insert value greater than root to right" time="0.002">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstInsert" name="should return existing node if value already exists" time="0.001">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstInsert" name="should build a valid BST" time="0.001">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstSearch" name="should find existing value" time="0.002">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstSearch" name="should return null for non-existent value" time="0">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstSearch" name="should find root value" time="0">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstMin" name="should find minimum value in BST" time="0">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstMin" name="should return root if it is minimum" time="0.001">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstMax" name="should find maximum value in BST" time="0.001">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstMax" name="should return root if it is maximum" time="0.001">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstSuccessor" name="should find successor of a node" time="0.002">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstSuccessor" name="should return null if no successor exists" time="0.002">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstPredecessor" name="should find predecessor of a node" time="0.001">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstPredecessor" name="should return null if no predecessor exists" time="0.004">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstDelete" name="should delete leaf node" time="0.002">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstDelete" name="should delete node with one child" time="0.001">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstDelete" name="should delete node with two children" time="0.002">
    </testcase>
    <testcase classname="Binary Search Tree Operations › bstDelete" name="should handle deletion of node with one child" time="0">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\statistics.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.136" tests="8">
    <testcase classname="Statistics › getStatistics" name="should return statistics for empty graph" time="0.006">
    </testcase>
    <testcase classname="Statistics › getStatistics" name="should calculate statistics for single leaf" time="0.001">
    </testcase>
    <testcase classname="Statistics › getStatistics" name="should calculate statistics for graph with branches" time="0.001">
    </testcase>
    <testcase classname="Statistics › getStatistics" name="should calculate weighted statistics" time="0.001">
    </testcase>
    <testcase classname="Statistics › getStatistics" name="should handle mixed weighted and unweighted branches" time="0.001">
    </testcase>
    <testcase classname="Statistics › getStatistics" name="should calculate statistics for undirected graph" time="0.002">
    </testcase>
    <testcase classname="Statistics › getStatistics" name="should calculate max and min degree correctly" time="0.001">
    </testcase>
    <testcase classname="Statistics › getStatistics" name="should handle complete graph" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\query.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.163" tests="15">
    <testcase classname="Query › findLeaves" name="should find leaves matching predicate" time="0.003">
    </testcase>
    <testcase classname="Query › findLeaves" name="should return empty array if no matches" time="0.001">
    </testcase>
    <testcase classname="Query › findLeaves" name="should respect limit option" time="0.001">
    </testcase>
    <testcase classname="Query › findLeaves" name="should respect offset option" time="0.001">
    </testcase>
    <testcase classname="Query › findLeaf" name="should find single leaf matching predicate" time="0.001">
    </testcase>
    <testcase classname="Query › findLeaf" name="should return undefined if no match" time="0">
    </testcase>
    <testcase classname="Query › findBranches" name="should find branches matching predicate" time="0.001">
    </testcase>
    <testcase classname="Query › findBranches" name="should respect limit option" time="0.001">
    </testcase>
    <testcase classname="Query › findBranch" name="should find single branch matching predicate" time="0.001">
    </testcase>
    <testcase classname="Query › findBranch" name="should return undefined if no match" time="0">
    </testcase>
    <testcase classname="Query › filterLeavesByValue" name="should filter leaves by property value" time="0.003">
    </testcase>
    <testcase classname="Query › filterLeavesByValue" name="should return empty array if no matches" time="0.001">
    </testcase>
    <testcase classname="Query › filterBranchesByWeight" name="should filter branches by weight range" time="0.001">
    </testcase>
    <testcase classname="Query › filterBranchesByWeight" name="should include boundaries" time="0">
    </testcase>
    <testcase classname="Query › filterBranchesByWeight" name="should handle unweighted branches" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\algorithms\shortestPath.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.136" tests="7">
    <testcase classname="shortestPath" name="should find shortest path in unweighted graph" time="0.002">
    </testcase>
    <testcase classname="shortestPath" name="should find shortest path in weighted graph" time="0.001">
    </testcase>
    <testcase classname="shortestPath" name="should return empty array if no path exists" time="0">
    </testcase>
    <testcase classname="shortestPath" name="should return single leaf if start equals end" time="0.001">
    </testcase>
    <testcase classname="shortestPath" name="should handle multiple paths and select minimum distance" time="0.014">
    </testcase>
    <testcase classname="shortestPath" name="should skip already visited neighbors in Dijkstra" time="0.001">
    </testcase>
    <testcase classname="shortestPath" name="should return empty array when no path exists in weighted graph" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\treeOperations.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.194" tests="26">
    <testcase classname="Tree Operations › findRoot" name="should find the root of a tree" time="0.002">
    </testcase>
    <testcase classname="Tree Operations › findRoot" name="should return null for empty graph" time="0">
    </testcase>
    <testcase classname="Tree Operations › findRoot" name="should throw error for multiple roots" time="0.028">
    </testcase>
    <testcase classname="Tree Operations › findRoot" name="should return first node if all have incoming edges" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › isRoot" name="should return true for root node" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › isRoot" name="should return false for non-root node" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › getRoot" name="should get root from any node" time="0">
    </testcase>
    <testcase classname="Tree Operations › getRoot" name="should throw error on cycle" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › getParent" name="should get parent of a node" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › getChildren" name="should get children of a node" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › getChildren" name="should return empty array for leaf node" time="0">
    </testcase>
    <testcase classname="Tree Operations › getSiblings" name="should get siblings of a node" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › getSiblings" name="should return empty array for root" time="0">
    </testcase>
    <testcase classname="Tree Operations › getSiblings" name="should return siblings for node4" time="0">
    </testcase>
    <testcase classname="Tree Operations › getAncestors" name="should get all ancestors of a node" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › getAncestors" name="should return empty array for root" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › getAncestors" name="should throw error on cycle" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › getDescendants" name="should get all descendants of a node" time="0.015">
    </testcase>
    <testcase classname="Tree Operations › getDescendants" name="should return empty array for leaf node" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › getHeight" name="should calculate height of tree" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › getHeight" name="should return 0 for single node" time="0">
    </testcase>
    <testcase classname="Tree Operations › getDepth" name="should calculate depth of a node" time="0.002">
    </testcase>
    <testcase classname="Tree Operations › getTreeSize" name="should calculate size of tree" time="0">
    </testcase>
    <testcase classname="Tree Operations › getTreeSize" name="should return 1 for single node" time="0.001">
    </testcase>
    <testcase classname="Tree Operations › getWidth" name="should calculate width of tree" time="0">
    </testcase>
    <testcase classname="Tree Operations › getWidth" name="should return 1 for single node" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\core\Graph.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="1.262" tests="29">
    <testcase classname="Graph › addLeaf" name="should add a leaf to the graph" time="0.016">
    </testcase>
    <testcase classname="Graph › addLeaf" name="should auto-generate ID if not provided" time="0.002">
    </testcase>
    <testcase classname="Graph › addLeaf" name="should use string value as ID when no ID provided" time="0.001">
    </testcase>
    <testcase classname="Graph › addLeaf" name="should use number value as ID when no ID provided" time="0.001">
    </testcase>
    <testcase classname="Graph › addLeaf" name="should allow addBranch with string IDs after addLeaf without ID" time="0.002">
    </testcase>
    <testcase classname="Graph › addLeaf" name="should throw error on duplicate ID" time="0.053">
    </testcase>
    <testcase classname="Graph › addBranch" name="should add a branch between two leaves" time="0.002">
    </testcase>
    <testcase classname="Graph › addBranch" name="should add weighted branch" time="0">
    </testcase>
    <testcase classname="Graph › addBranch" name="should add branch using string IDs" time="0.001">
    </testcase>
    <testcase classname="Graph › addBranch" name="should add branch using number IDs" time="0.001">
    </testcase>
    <testcase classname="Graph › addBranch" name="should add branch mixing Node objects and IDs" time="0.002">
    </testcase>
    <testcase classname="Graph › addBranch" name="should throw error when source ID not found" time="0.002">
    </testcase>
    <testcase classname="Graph › addBranch" name="should throw error when target ID not found" time="0.02">
    </testcase>
    <testcase classname="Graph › addBranch" name="should throw error if source leaf not in graph" time="0.001">
    </testcase>
    <testcase classname="Graph › addBranch" name="should throw error if target leaf not in graph" time="0.001">
    </testcase>
    <testcase classname="Graph › removeLeaf" name="should remove a leaf and its branches" time="0.002">
    </testcase>
    <testcase classname="Graph › removeLeaf" name="should handle removing leaf that does not exist" time="0">
    </testcase>
    <testcase classname="Graph › removeBranch" name="should remove a branch" time="0.001">
    </testcase>
    <testcase classname="Graph › getLeaf" name="should return leaf by ID" time="0.001">
    </testcase>
    <testcase classname="Graph › getLeaf" name="should return undefined for non-existent leaf" time="0">
    </testcase>
    <testcase classname="Graph › leaves and branches" name="should return all leaves" time="0.001">
    </testcase>
    <testcase classname="Graph › leaves and branches" name="should return all branches" time="0.001">
    </testcase>
    <testcase classname="Graph › size and isEmpty" name="should return correct size" time="0">
    </testcase>
    <testcase classname="Graph › size and isEmpty" name="should return true for empty graph" time="0.001">
    </testcase>
    <testcase classname="Graph › clear" name="should clear all leaves and branches" time="0.001">
    </testcase>
    <testcase classname="Graph › iterators" name="should iterate over leaves efficiently" time="0.001">
    </testcase>
    <testcase classname="Graph › iterators" name="should iterate over branches efficiently" time="0">
    </testcase>
    <testcase classname="Graph › constructor with data" name="should create graph from data array" time="0">
    </testcase>
    <testcase classname="Graph › ID generation failure" name="should throw error when unable to generate unique ID" time="0.01">
    </testcase>
  </testsuite>
  <testsuite name="tests\errors\GraphError.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.186" tests="5">
    <testcase classname="GraphError" name="should create graph error with default code" time="0.003">
    </testcase>
    <testcase classname="GraphError" name="should create graph error with custom code" time="0.001">
    </testcase>
    <testcase classname="GraphError" name="should create graph error with path" time="0">
    </testcase>
    <testcase classname="GraphError" name="should create graph error with cause" time="0">
    </testcase>
    <testcase classname="GraphError" name="should create graph error with both path and cause" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\errors\TypeError.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.112" tests="2">
    <testcase classname="TypeError" name="should create type error" time="0.002">
    </testcase>
    <testcase classname="TypeError" name="should use default code if not provided" time="0">
    </testcase>
  </testsuite>
  <testsuite name="tests\algorithms\pathFinding.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.137" tests="14">
    <testcase classname="Path Finding with Constraints › findPathsWithConstraints" name="should find paths with maxLength constraint" time="0.002">
    </testcase>
    <testcase classname="Path Finding with Constraints › findPathsWithConstraints" name="should find paths with maxWeight constraint" time="0.001">
    </testcase>
    <testcase classname="Path Finding with Constraints › findPathsWithConstraints" name="should stop early when currentWeight already equals maxWeight" time="0.001">
    </testcase>
    <testcase classname="Path Finding with Constraints › findPathsWithConstraints" name="should find paths with branchFilter" time="0">
    </testcase>
    <testcase classname="Path Finding with Constraints › findPathsWithConstraints" name="should find paths with leafFilter" time="0.001">
    </testcase>
    <testcase classname="Path Finding with Constraints › findPathsWithConstraints" name="should respect maxPaths constraint" time="0">
    </testcase>
    <testcase classname="Path Finding with Constraints › findPathsWithConstraints" name="should return empty array if no path exists" time="0.001">
    </testcase>
    <testcase classname="Path Finding with Constraints › findShortestPathWithConstraints" name="should find shortest path with constraints" time="0.001">
    </testcase>
    <testcase classname="Path Finding with Constraints › findShortestPathWithConstraints" name="should select shortest path when multiple paths exist" time="0.001">
    </testcase>
    <testcase classname="Path Finding with Constraints › findShortestPathWithConstraints" name="should return empty array if no path exists" time="0">
    </testcase>
    <testcase classname="Path Finding with Constraints › findPathsAvoiding" name="should find paths avoiding specific leaves" time="0">
    </testcase>
    <testcase classname="Path Finding with Constraints › findPathsAvoiding" name="should return empty array if all paths are blocked" time="0.001">
    </testcase>
    <testcase classname="Path Finding with Constraints › findPathsThrough" name="should find paths through required leaves" time="0.001">
    </testcase>
    <testcase classname="Path Finding with Constraints › findPathsThrough" name="should return empty array if no path includes required leaves" time="0">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\renderASCII.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.13" tests="14">
    <testcase classname="renderASCII" name="should render empty graph" time="0.001">
    </testcase>
    <testcase classname="renderASCII" name="should render graph with single leaf" time="0.001">
    </testcase>
    <testcase classname="renderASCII" name="should render graph with branches" time="0">
    </testcase>
    <testcase classname="renderASCII" name="should show weights when specified" time="0">
    </testcase>
    <testcase classname="renderASCII" name="should show IDs when specified" time="0.001">
    </testcase>
    <testcase classname="renderASCII" name="should respect maxDepth option" time="0">
    </testcase>
    <testcase classname="renderASCII" name="should find root leaf when not provided and graph has no incoming branches" time="0.001">
    </testcase>
    <testcase classname="renderASCII" name="should fallback to first leaf when all leaves have incoming branches" time="0">
    </testcase>
    <testcase classname="renderASCII" name="should handle null values" time="0">
    </testcase>
    <testcase classname="renderASCII" name="should handle undefined values" time="0.001">
    </testcase>
    <testcase classname="renderASCII" name="should handle array values" time="0">
    </testcase>
    <testcase classname="renderASCII" name="should handle empty object values" time="0.001">
    </testcase>
    <testcase classname="renderASCII" name="should handle objects with many keys" time="0">
    </testcase>
    <testcase classname="renderASCII" name="should handle depth exceeding maxDepth in renderLeaf" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\normalize.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.156" tests="6">
    <testcase classname="normalize" name="should normalize nested JSON" time="0.002">
    </testcase>
    <testcase classname="normalize" name="should convert string numbers to numbers" time="0.001">
    </testcase>
    <testcase classname="normalize" name="should convert string booleans to booleans" time="0.001">
    </testcase>
    <testcase classname="normalize" name="should handle required fields option" time="0.001">
    </testcase>
    <testcase classname="normalize" name="should handle arrays" time="0.001">
    </testcase>
    <testcase classname="normalize" name="should handle null and undefined" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\algorithms\connectedComponents.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.162" tests="13">
    <testcase classname="Connected Components › findConnectedComponents" name="should find single component for connected graph" time="0.003">
    </testcase>
    <testcase classname="Connected Components › findConnectedComponents" name="should find multiple components for disconnected graph" time="0.002">
    </testcase>
    <testcase classname="Connected Components › findConnectedComponents" name="should handle empty graph" time="0.001">
    </testcase>
    <testcase classname="Connected Components › findConnectedComponents" name="should handle all isolated leaves" time="0.001">
    </testcase>
    <testcase classname="Connected Components › findConnectedComponents" name="should handle complex connected graph" time="0.001">
    </testcase>
    <testcase classname="Connected Components › findConnectedComponents" name="should handle bidirectional branches in undirected graph" time="0.001">
    </testcase>
    <testcase classname="Connected Components › findStronglyConnectedComponents" name="should find strongly connected components" time="0.002">
    </testcase>
    <testcase classname="Connected Components › findStronglyConnectedComponents" name="should handle DAG (each node is its own component)" time="0.001">
    </testcase>
    <testcase classname="Connected Components › findStronglyConnectedComponents" name="should handle strongly connected component with multiple nodes" time="0.002">
    </testcase>
    <testcase classname="Connected Components › findStronglyConnectedComponents" name="should handle empty graph" time="0.001">
    </testcase>
    <testcase classname="Connected Components › countConnectedComponents" name="should count connected components" time="0.001">
    </testcase>
    <testcase classname="Connected Components › countConnectedComponents" name="should return 0 for empty graph" time="0.001">
    </testcase>
    <testcase classname="Connected Components › countConnectedComponents" name="should return 1 for fully connected graph" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\treeValidation.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.19" tests="18">
    <testcase classname="Tree Validation › isTree" name="should return true for valid tree" time="0.004">
    </testcase>
    <testcase classname="Tree Validation › isTree" name="should return false for graph with cycle" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isTree" name="should return true for empty graph" time="0">
    </testcase>
    <testcase classname="Tree Validation › isTree" name="should return false for disconnected graph" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isBST" name="should return true for valid BST" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isBST" name="should return false for invalid BST" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isBST" name="should work with custom compare function" time="0.018">
    </testcase>
    <testcase classname="Tree Validation › isBST" name="should return true for single node" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isBalanced" name="should return true for balanced tree" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isBalanced" name="should return false for unbalanced tree" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isBalanced" name="should return true for single node" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isComplete" name="should return true for complete binary tree" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isComplete" name="should return true for single node" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isFull" name="should return true for full binary tree" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isFull" name="should return false for tree with node having one child" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isFull" name="should return true for single node (leaf)" time="0.001">
    </testcase>
    <testcase classname="Tree Validation › isPerfect" name="should return true for perfect binary tree" time="0.002">
    </testcase>
    <testcase classname="Tree Validation › isPerfect" name="should return true for single node" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\core\Node.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.133" tests="8">
    <testcase classname="Node › addBranch" name="should add a branch" time="0.001">
    </testcase>
    <testcase classname="Node › addBranch" name="should not add duplicate branch" time="0">
    </testcase>
    <testcase classname="Node › addBranch" name="should throw error if branch does not originate from this node" time="0.011">
    </testcase>
    <testcase classname="Node › removeBranch" name="should remove a branch" time="0.001">
    </testcase>
    <testcase classname="Node › getConnectedLeaves" name="should return all connected leaves" time="0.001">
    </testcase>
    <testcase classname="Node › hasBranchTo" name="should return true if branch exists" time="0.001">
    </testcase>
    <testcase classname="Node › hasBranchTo" name="should return false if branch does not exist" time="0.001">
    </testcase>
    <testcase classname="Node › getOutDegree" name="should return number of outgoing branches" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\algorithms\cycleDetection.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.124" tests="3">
    <testcase classname="detectCycles" name="should detect cycle in graph" time="0.003">
    </testcase>
    <testcase classname="detectCycles" name="should return false for acyclic graph" time="0.001">
    </testcase>
    <testcase classname="detectCycles" name="should return false for single leaf" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\algorithms\allPaths.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.132" tests="6">
    <testcase classname="allPaths" name="should find all paths between two leaves" time="0.002">
    </testcase>
    <testcase classname="allPaths" name="should return single path for direct connection" time="0.002">
    </testcase>
    <testcase classname="allPaths" name="should return empty array if no path exists" time="0">
    </testcase>
    <testcase classname="allPaths" name="should return single node path when start equals end" time="0.001">
    </testcase>
    <testcase classname="allPaths" name="should skip nodes already in current path to avoid cycles" time="0.001">
    </testcase>
    <testcase classname="allPaths" name="should handle complex cycle scenario to trigger continue statement" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\errors\TreeError.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.12" tests="2">
    <testcase classname="TreeError" name="should create tree error" time="0">
    </testcase>
    <testcase classname="TreeError" name="should use default code if not provided" time="0">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\validate-edge-cases.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.111" tests="10">
    <testcase classname="validate - Edge Cases" name="should handle optional fields with null values" time="0.001">
    </testcase>
    <testcase classname="validate - Edge Cases" name="should validate date string" time="0">
    </testcase>
    <testcase classname="validate - Edge Cases" name="should validate date string (even if invalid date)" time="0">
    </testcase>
    <testcase classname="validate - Edge Cases" name="should handle array with invalid items" time="0.001">
    </testcase>
    <testcase classname="validate - Edge Cases" name="should handle nested object validation errors" time="0.001">
    </testcase>
    <testcase classname="validate - Edge Cases" name="should handle custom validator returning string" time="0">
    </testcase>
    <testcase classname="validate - Edge Cases" name="should handle custom validator returning true" time="0">
    </testcase>
    <testcase classname="validate - Edge Cases" name="should handle number enum validation" time="0">
    </testcase>
    <testcase classname="validate - Edge Cases" name="should fail number enum validation" time="0">
    </testcase>
    <testcase classname="validate - Edge Cases" name="should handle string enum validation failure" time="0">
    </testcase>
  </testsuite>
  <testsuite name="tests\algorithms\bfs.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.086" tests="9">
    <testcase classname="BFS" name="should traverse graph in breadth-first order" time="0.001">
    </testcase>
    <testcase classname="BFS" name="should call visit callback for each leaf" time="0">
    </testcase>
    <testcase classname="BFS" name="should handle single leaf" time="0">
    </testcase>
    <testcase classname="BFS" name="should find leaf matching predicate with early termination" time="0.001">
    </testcase>
    <testcase classname="BFS" name="should return undefined if no match found with predicate" time="0">
    </testcase>
    <testcase classname="BFS" name="should stop searching once match is found (early termination)" time="0.001">
    </testcase>
    <testcase classname="BFS" name="should find leaf by value property with predicate" time="0">
    </testcase>
    <testcase classname="BFS" name="should handle complex predicate conditions" time="0">
    </testcase>
    <testcase classname="BFS" name="should return start leaf if it matches predicate" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\utils\mergeGraph.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:39" time="0.104" tests="5">
    <testcase classname="mergeGraph" name="should merge two graphs" time="0.001">
    </testcase>
    <testcase classname="mergeGraph" name="should skip duplicate leaves by default" time="0">
    </testcase>
    <testcase classname="mergeGraph" name="should overwrite duplicate leaves when specified" time="0">
    </testcase>
    <testcase classname="mergeGraph" name="should throw error on conflict when specified" time="0.007">
    </testcase>
    <testcase classname="mergeGraph" name="should merge branches when mergeBranches is true" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="tests\integration\full-examples.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="3.012" tests="7">
    <testcase classname="Full Integration Tests" name="should pass User Provided Example" time="0.099">
    </testcase>
    <testcase classname="Full Integration Tests" name="should pass Social Network Example" time="0.065">
    </testcase>
    <testcase classname="Full Integration Tests" name="should pass Supply Chain Example" time="0.056">
    </testcase>
    <testcase classname="Full Integration Tests" name="should pass Nested JSON Example" time="0.053">
    </testcase>
    <testcase classname="Full Integration Tests" name="should pass String Value as ID" time="0.05">
    </testcase>
    <testcase classname="Full Integration Tests" name="should pass Number Value as ID" time="0.052">
    </testcase>
    <testcase classname="Full Integration Tests" name="should pass Object Value Auto-ID" time="0.054">
    </testcase>
  </testsuite>
  <testsuite name="tests\integration\integration.test.ts" errors="0" failures="0" skipped="0" timestamp="2025-12-29T23:54:38" time="3.287" tests="11">
    <testcase classname="Integration Tests" name="should pass Basic Graph Operations" time="0.093">
    </testcase>
    <testcase classname="Integration Tests" name="should pass BFS and DFS" time="0.063">
    </testcase>
    <testcase classname="Integration Tests" name="should pass Shortest Path" time="0.061">
    </testcase>
    <testcase classname="Integration Tests" name="should pass Auto-generated IDs" time="0.053">
    </testcase>
    <testcase classname="Integration Tests" name="should pass Number IDs" time="0.05">
    </testcase>
    <testcase classname="Integration Tests" name="should pass Mixed Node objects and IDs" time="0.051">
    </testcase>
    <testcase classname="Integration Tests" name="should pass Error Handling" time="0.051">
    </testcase>
    <testcase classname="Integration Tests" name="should pass Complex Graph Operations" time="0.055">
    </testcase>
    <testcase classname="Integration Tests" name="should pass JSON Serialization" time="0.053">
    </testcase>
    <testcase classname="Integration Tests" name="should pass Statistics" time="0.051">
    </testcase>
    <testcase classname="Integration Tests" name="should pass Common Mistake: addLeaf without ID then addBranch with value" time="0.067">
    </testcase>
  </testsuite>
</testsuites>