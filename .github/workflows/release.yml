name: Release

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.github/**'
  pull_request:
    types: [closed]
    branches:
      - main
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type (auto, major, minor, patch)'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - major
          - minor
          - patch

jobs:
  create-version-pr:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' &&
      !contains(github.event.head_commit.message, 'chore: bump version')
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check for existing prepare-release PRs
        id: check_prs
        run: |
          EXISTING_PRS=$(gh pr list --label "prepare-release" --state open --json number --jq '.[].number' || echo "")
          if [ -n "$EXISTING_PRS" ]; then
            echo "existing_prs=$EXISTING_PRS" >> $GITHUB_OUTPUT
            echo "has_existing=true" >> $GITHUB_OUTPUT
            echo "Found existing prepare-release PRs: $EXISTING_PRS"
          else
            echo "has_existing=false" >> $GITHUB_OUTPUT
            echo "No existing prepare-release PRs found"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Close existing prepare-release PRs
        if: steps.check_prs.outputs.has_existing == 'true'
        run: |
          PRS="${{ steps.check_prs.outputs.existing_prs }}"
          for pr in $PRS; do
            echo "Closing PR #$pr"
            gh pr close $pr --comment "Closing in favor of new prepare-release PR"
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get latest tag
        id: latest_tag
        run: |
          TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $TAG"

      - name: Get current version from package.json
        id: current_version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "current_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"

      - name: Determine version bump
        id: version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
          LATEST_TAG="${{ steps.latest_tag.outputs.latest_tag }}"

          # Get commits since latest tag
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" --no-merges)
          else
            COMMITS=$(git log --pretty=format:"%s" --no-merges)
          fi
          
          # Analyze commits for conventional commits
          MAJOR=false
          MINOR=false
          
          while IFS= read -r commit; do
            # Check for breaking changes
            if echo "$commit" | grep -qiE "(BREAKING CHANGE|!|^[^:]*!:)"; then
              MAJOR=true
            fi
            # Check for features
            if echo "$commit" | grep -qiE "^feat(\(.+\))?:"; then
              MINOR=true
            fi
          done <<< "$COMMITS"
          
          if [ "$MAJOR" = true ]; then
            VERSION_TYPE="major"
          elif [ "$MINOR" = true ]; then
            VERSION_TYPE="minor"
          else
            VERSION_TYPE="patch"
          fi

          # Calculate new version
          IFS='.' read -r MAJOR MINOR PATCH <<< "${CURRENT_VERSION##v}"

          case "$VERSION_TYPE" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          NEW_TAG="v${NEW_VERSION}"

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT

          echo "Version bump type: $VERSION_TYPE"
          echo "New version: $NEW_VERSION"
          echo "New tag: $NEW_TAG"

      - name: Create branch for version bump
        run: |
          BRANCH_NAME="prepare-release/v${{ steps.version.outputs.version }}"
          git checkout -b "$BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
        id: branch

      - name: Update package.json version
        run: |
          NEW_VERSION="${{ steps.version.outputs.version }}"
          npm version $NEW_VERSION --no-git-tag-version
          echo "Updated package.json to version $NEW_VERSION"

      - name: Commit version update
        run: |
          git add package.json package-lock.json
          git commit -m "chore: bump version to ${{ steps.version.outputs.version }}"

      - name: Push branch
        run: |
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          git push origin "${{ steps.branch.outputs.branch_name }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate changelog
        id: changelog
        run: |
          LATEST_TAG="${{ steps.latest_tag.outputs.latest_tag }}"
          NEW_TAG="${{ steps.version.outputs.tag }}"

          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges)
          fi

          if [ -z "$COMMITS" ]; then
            COMMITS="- No changes since last release"
          fi

          CHANGELOG=$(cat <<EOF
          ## Changes in ${NEW_TAG}

          ### Commits
          ${COMMITS}

          See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details.
          EOF
          )

          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ steps.branch.outputs.branch_name }}
          title: "chore: prepare release v${{ steps.version.outputs.version }}"
          body: |
            ## Version Bump: ${{ steps.version.outputs.version }}
            
            **Version Type:** ${{ steps.version.outputs.version_type }}
            
            This PR prepares the release by bumping the version in `package.json`.
            
            Once merged, the release workflow will automatically:
            - Create tag `${{ steps.version.outputs.tag }}`
            - Publish to npm
            - Create GitHub release
            
            ${{ steps.changelog.outputs.body }}
          labels: |
            prepare-release
            automated
          draft: false

  release:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'pull_request' && 
       github.event.pull_request.merged == true && 
       contains(github.event.pull_request.labels.*.name, 'prepare-release')) ||
      (github.event_name == 'workflow_dispatch')
    permissions:
      contents: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get version from merged PR
        if: github.event_name == 'pull_request'
        id: pr_version
        run: |
          # Extract version from PR title or package.json
          if [ -f package.json ]; then
            VERSION=$(node -p "require('./package.json').version")
            TAG="v${VERSION}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT
          else
            echo "Error: package.json not found"
            exit 1
          fi

      - name: Get version for manual dispatch
        if: github.event_name == 'workflow_dispatch'
        id: manual_version
        run: |
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")

          if [ "$VERSION_TYPE" = "auto" ] || [ -z "$VERSION_TYPE" ]; then
            if [ "$LATEST_TAG" != "v0.0.0" ]; then
              COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" --no-merges)
            else
              COMMITS=$(git log --pretty=format:"%s" --no-merges)
            fi
            
            MAJOR=false
            MINOR=false
            
            while IFS= read -r commit; do
              if echo "$commit" | grep -qiE "(BREAKING CHANGE|!|^[^:]*!:)"; then
                MAJOR=true
              fi
              if echo "$commit" | grep -qiE "^feat(\(.+\))?:"; then
                MINOR=true
              fi
            done <<< "$COMMITS"
            
            if [ "$MAJOR" = true ]; then
              VERSION_TYPE="major"
            elif [ "$MINOR" = true ]; then
              VERSION_TYPE="minor"
            else
              VERSION_TYPE="patch"
            fi
          fi

          IFS='.' read -r MAJOR MINOR PATCH <<< "${CURRENT_VERSION##v}"

          case "$VERSION_TYPE" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          NEW_TAG="v${NEW_VERSION}"

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          TAG="${{ github.event_name == 'pull_request' && steps.pr_version.outputs.tag || steps.manual_version.outputs.tag }}"
          LATEST_TAG=$(git describe --tags --abbrev=0 ${TAG}^ 2>/dev/null || echo "")

          if [ -n "$LATEST_TAG" ]; then
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges -n 20)
          fi

          if [ -z "$COMMITS" ]; then
            COMMITS="- No changes since last release"
          fi

          CHANGELOG=$(cat <<EOF
          ## Changes in ${TAG}

          ### Commits
          ${COMMITS}

          See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details.
          EOF
          )

          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create and push tag
        run: |
          TAG="${{ github.event_name == 'pull_request' && steps.pr_version.outputs.tag || steps.manual_version.outputs.tag }}"
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"
          echo "Created and pushed tag: $TAG"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Run tests
        run: npm test

      - name: Build project
        run: npm run build

      - name: Check bundle size
        run: npm run size

      - name: Publish to npm
        run: npm publish --access public --provenance
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.event_name == 'pull_request' && steps.pr_version.outputs.tag || steps.manual_version.outputs.tag }}
          name: Release ${{ github.event_name == 'pull_request' && steps.pr_version.outputs.tag || steps.manual_version.outputs.tag }}
          body: ${{ steps.changelog.outputs.body }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
